diff -r tensorflow-1.3.0/tensorflow/contrib/cmake/CMakeLists.txt tensorflow-1.3.0-mod/tensorflow/contrib/cmake/CMakeLists.txt
34c34
< option(tensorflow_WIN_CPU_SIMD_OPTIONS "Enables CPU SIMD instructions")
---
> set(tensorflow_WIN_CPU_SIMD_OPTIONS "${tensorflow_WIN_CPU_SIMD_OPTIONS}")
diff -r tensorflow-1.3.0/tensorflow/contrib/cmake/external/re2.cmake tensorflow-1.3.0-mod/tensorflow/contrib/cmake/external/re2.cmake
43a44
>         -DRE2_BUILD_TESTING:BOOL=OFF
diff -r tensorflow-1.3.0/tensorflow/core/common_runtime/local_device.cc tensorflow-1.3.0-mod/tensorflow/core/common_runtime/local_device.cc
67c67
<   port::WarnAboutUnusedCPUFeatures();
---
>   //port::WarnAboutUnusedCPUFeatures();
diff -r tensorflow-1.3.0/tensorflow/core/framework/types.h tensorflow-1.3.0-mod/tensorflow/core/framework/types.h
72,74c72,74
< TF_EXPORT extern const char* const DEVICE_CPU;   // "CPU"
< TF_EXPORT extern const char* const DEVICE_GPU;   // "GPU"
< TF_EXPORT extern const char* const DEVICE_SYCL;  // "SYCL"
---
> /*TF_EXPORT*/ extern const char* const DEVICE_CPU;   // "CPU"
> /*TF_EXPORT*/ extern const char* const DEVICE_GPU;   // "GPU"
> /*TF_EXPORT*/ extern const char* const DEVICE_SYCL;  // "SYCL"
diff -r tensorflow-1.3.0/tensorflow/core/kernels/quantization_utils.h tensorflow-1.3.0-mod/tensorflow/core/kernels/quantization_utils.h
36c36
< #include "public/gemmlowp.h"
---
> //#include "public/gemmlowp.h"
899,959d898
< 
< // See gemmlowp/internal/multi_thread_gemm.h for definitions of
< // Prepare, Wait, StartWorker, and CreateWorkers.
< class TensorflowGemmlowpWorkersPool {
<  public:
<   TensorflowGemmlowpWorkersPool(thread::ThreadPool* workers)
<       : workers_(workers) {}
< 
<   ~TensorflowGemmlowpWorkersPool() {
<     // This workaround ensures that all worker tasks have exited methods in the
<     // BlockingCounter. Without this, there is a race where the context is torn
<     // down while the counter is in use.
<     counter_to_decrement_when_ready_.Reset(0);
<   }
< 
<   void Prepare(int workers_count) {
<     counter_to_decrement_when_ready_.Reset(workers_count);
<   }
< 
<   void Wait() { counter_to_decrement_when_ready_.Wait(); }
< 
<   void StartWorker(int index, gemmlowp::Task* task) {
<     CHECK(workers_ != nullptr);
<     // <index> is ignored - the tensorflow threadpool does not support assigning
<     // to a specific thread.
<     workers_->Schedule([this, task]() {
<       // TODO(cwhipkey): get a local_allocator from a thread local.
<       gemmlowp::Allocator local_allocator;
<       CHECK(task != nullptr);
<       task->local_allocator = &local_allocator;
<       task->Run();
<       delete task;
<       counter_to_decrement_when_ready_.DecrementCount();
<     });
<   }
< 
<   void CreateWorkers(std::size_t workers_count) {}
< 
<  private:
<   thread::ThreadPool* const workers_;
< 
<   // The BlockingCounter used to wait for the workers.
<   gemmlowp::BlockingCounter counter_to_decrement_when_ready_;
< 
<   TF_DISALLOW_COPY_AND_ASSIGN(TensorflowGemmlowpWorkersPool);
< };
< 
< class TensorflowGemmContext : public gemmlowp::MultiThreadGemmContextBase {
<  public:
<   TensorflowGemmContext(int num_threads, thread::ThreadPool* workers)
<       : workers_pool_(workers) {
<     set_max_num_threads(num_threads);
<   }
< 
<   TensorflowGemmlowpWorkersPool* workers_pool() { return &workers_pool_; }
< 
<  private:
<   TensorflowGemmlowpWorkersPool workers_pool_;
< 
<   TF_DISALLOW_COPY_AND_ASSIGN(TensorflowGemmContext);
< };
